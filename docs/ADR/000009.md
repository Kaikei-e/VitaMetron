# Fitbit HRV レスポンスの JSON タグ不一致によるデータ欠損の修正

## ADR's STATUS

採用済み (2026-02-25)

## CONTEXT

Fitbit 上では HRV（Heart Rate Variability）メトリクスが正常に取得できているにもかかわらず、VitaMetron のダッシュボードでは HRV が `--`（データなし）として表示されていた。

### データフロー

```
Fitbit API (/1/user/-/hrv/date/{date}.json)
  → FetchHRV() で JSON デコード
    → Float32Ptr() で *float32 に変換
      → DailySummaryRepo.Upsert() で DB に書き込み
        → API レスポンス → フロントエンド表示
```

### DB の状態（調査時点）

| 期間 | hrv_daily_rmssd | hrv_deep_rmssd |
|---|---|---|
| 2024-11-10 以前 | 正常値あり | NULL |
| 2026-02-12〜02-20 | 正常値あり | 常に 0 |
| 2026-02-21〜02-24 | 0 | 0 |
| 2026-02-25（当日） | NULL | NULL |

`hrv_deep_rmssd` が全期間で 0 であり、`hrv_daily_rmssd` も直近で 0 に変わっていることから、Fitbit API レスポンスの**パース段階**で問題が発生していると推定。

### 根本原因

Fitbit HRV API の実レスポンス:

```json
{
  "hrv": [
    {
      "value": {
        "dailyRmssd": 50.609,
        "deepRmssd": 49.338
      },
      "dateTime": "2026-02-24"
    }
  ]
}
```

Go 側の `HRVResponse` 構造体:

```go
type HRVResponse struct {
    HRV []struct {
        HRV struct {
            DailyRMSSD float32 `json:"dailyRmssd"`
            DeepRMSSD  float32 `json:"deepRmssd"`
        } `json:"hrv"`  // ← ここが間違い。実際のキーは "value"
    } `json:"hrv"`
}
```

内側の JSON タグが `"hrv"` になっていたが、Fitbit API は `"value"` を返す。Go の `json.Decoder` はキーが一致しないフィールドを無視するため、`DailyRMSSD` / `DeepRMSSD` が常にゼロ値 (`0.0`) のまま残っていた。

### 0 が固着するメカニズム

旧コードでは `HRVDailyRMSSD` が `float32` 型（ポインタではない）だったため:

1. FetchHRV がパース失敗で `0.0` を返す → そのまま `summary.HRVDailyRMSSD = 0` に代入
2. Upsert の INSERT で `0` が DB に直接書き込まれる
3. 以降の UPDATE では `COALESCE(NULLIF(0, 0), existing_0)` → `COALESCE(NULL, 0)` → **0 のまま固着**

## DECISION MAKING

### 検討した選択肢

| 選択肢 | 概要 | 評価 |
|---|---|---|
| A. JSON タグの修正 | `json:"hrv"` → `json:"value"` に変更 | ✅ 採用 |
| B. カスタム UnmarshalJSON | 両方のキーに対応する柔軟なデコーダを実装 | △ 過剰対応。Fitbit API の仕様は `"value"` で安定 |
| C. Raw JSON + 手動パース | 生レスポンスから直接値を抽出 | △ 保守性が低下 |

### 選択肢 A を採用した理由

- **1行変更で根本原因を解消**: JSON タグの修正のみでパースが正常に動作する
- **影響範囲が最小**: `response.go` のタグ変更のみ、ロジック変更なし
- **Fitbit API 仕様との整合**: 公式ドキュメントと実レスポンスの両方が `"value"` キーを使用

### 併せて適用済みの関連修正

`float32` → `*float32` への型変更と `Float32Ptr()` ヘルパーの導入（別の変更セット）により、今後 FetchHRV が失敗した場合でも `nil`（= SQL NULL）が使われ、0 の固着問題が再発しない構造になっている。

## RESULTS, EFFECTS

### PROS

- **HRV データが正しく取得・保存される**: `dailyRmssd` / `deepRmssd` の両方が正常値で DB に格納
- **既存データの復旧が可能**: 日付指定の手動同期 (`POST /api/sync?date=YYYY-MM-DD`) でバックフィル可能
- **変更量が最小限**: `response.go` の JSON タグ1箇所のみ

### CONS, TRADEOFF

- **既存の不正データ（0値）は自動修復されない**: バックフィル同期を手動で実行する必要がある。ただし Upsert の `COALESCE(NULLIF($x, 0), existing)` パターンにより、0 を NULL 化した上で再同期すれば正しい値で上書きされる
- **Fitbit API のレスポンス形式変更に対する防御がない**: 今後 API 仕様が変わった場合、同様の不整合が発生する可能性がある。ただし現時点では過剰対応を避け、シンプルな構造体マッピングを維持する

## APPENDIX

### 変更ファイル

| ファイル | 変更内容 |
|---|---|
| `api/adapter/fitbit/response.go` | `HRVResponse` 内側の JSON タグを `json:"hrv"` → `json:"value"` に修正 |

### データ復旧手順

```sql
-- 不正な 0 値を NULL 化
UPDATE daily_summaries SET hrv_daily_rmssd = NULL WHERE hrv_daily_rmssd = 0;
UPDATE daily_summaries SET hrv_deep_rmssd = NULL WHERE hrv_deep_rmssd = 0;
```

```bash
# 日付ごとに再同期（Fitbit から最新データを取得）
for d in 2026-02-{12..24}; do
  curl -X POST "http://localhost:8880/api/sync?date=$d"
  sleep 1
done
```
