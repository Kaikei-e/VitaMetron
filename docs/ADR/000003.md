# PostgreSQL セッションタイムゾーンを Asia/Tokyo に設定し DATE 列クエリのずれを修正

## ADR's STATUS

採用済み (2026-02-19)

## CONTEXT

`/conditions` ページの「Actual vs Expected Condition」チャートで、今日（2/19）のデータが表示されない問題が発生した。X軸が前日で止まり、主観データ（Actual）と客観データ（Expected）の両方が欠落していた。

### 根本原因

Go API の `parseDate()` が JST midnight の `time.Time` を返すようになった結果、PostgreSQL の `DATE` 列との比較で1日ずれが発生していた。

以前の `parseDate()` は `time.Parse()`（UTC midnight）を使用しており正常だった。JST 対応のために `time.ParseInLocation("2006-01-02", s, jst)` に変更した際、PostgreSQL 側の暗黙変換との不整合が生じた。

**データの流れ:**

```
1. フロントエンド SSR → to=2026-02-19 を送信
2. Go API parseDate("2026-02-19") → 2026-02-19 00:00:00 +09:00 JST
3. pgx → PostgreSQL に TIMESTAMPTZ 2026-02-18 15:00:00+00 として送信
4. PostgreSQL が DATE 列と比較 → セッション TZ（デフォルト UTC）で暗黙変換
5. 2026-02-18 15:00:00 UTC → DATE '2026-02-18'（本来 2026-02-19 であるべき）
6. WHERE date BETWEEN ... AND '2026-02-18' → 今日のデータが漏れる
```

### 影響範囲

**影響あり（DATE 型の PRIMARY KEY を持つテーブル）:**

| テーブル | カラム | エンドポイント |
|---|---|---|
| `divergence_detections` | `date` | `/api/divergence` |
| `daily_summaries` | `date` | `/api/biometrics` |
| `vri_scores` | `date` | `/api/vri` |
| `anomaly_detections` | `date` | `/api/anomaly` |
| `daily_data_quality` | `date` | `/api/biometrics/quality` |

読み取りだけでなく書き込みにも影響があった。バックグラウンド同期が `time.Now()`（JST）を `DATE` カラムに書き込む際、00:00〜09:00 JST の時間帯では前日の日付として保存されてしまう問題があった。

**影響なし（TIMESTAMPTZ 列）:**
- `condition_logs.logged_at` — TIMESTAMPTZ 同士の比較はセッション TZ に依存しないため正常
- `heart_rate_intraday.time`, `sleep_stages.time` — 同上

### ウェアラブル API との整合性

ウェアラブルデバイスの API は全ての日付・時刻フィールドをユーザーのプロフィール TZ（JST）で返す。Go API の mapper コードは JST としてパースしており正しい。問題はデバイス API のハンドリングではなく、**Go から PostgreSQL への DATE 列書き込み/読み取り時の暗黙変換**にあった。

## DECISION MAKING

### 決定1: PostgreSQL セッションタイムゾーンを Asia/Tokyo に設定

**検討した選択肢:**

| 選択肢 | 概要 | 評価 |
|---|---|---|
| A. parseDate を UTC midnight に戻す | JST 対応を撤回 | ❌ ウェアラブルデータが JST で来るため不整合 |
| B. DATE 列を TIMESTAMPTZ に変更 | スキーマ変更 | ❌ 大規模マイグレーション、カレンダー日付の意味を失う |
| C. Go 側で DATE 文字列として送信 | `date.Format("2006-01-02")` を使用 | △ 全リポジトリの変更が必要、漏れのリスク |
| D. セッション TZ を Asia/Tokyo に設定 | 接続パラメータの変更のみ | ✅ 採用 |

**選択肢 D を採用した理由:**

- 変更箇所が接続プール初期化の1箇所に集約される
- 暗黙変換が JST で行われるようになり、`parseDate()`（JST midnight）→ `DATE` の変換が正しくなる
- 書き込み（`time.Now()` → DATE）も同時に修正される
- 既存の TIMESTAMPTZ 同士の比較には影響しない（絶対的な UTC 時刻で比較されるため）

### 決定2: ML サービス・前処理サービスにも防御的に適用

Python の `datetime.date` は純粋な日付型であり、asyncpg は PostgreSQL の `date` 型として直接送信するため、現時点では影響を受けない。しかし、将来 `datetime.datetime` を `DATE` カラムに対して使用した場合のリスクを排除するため、同様の設定を適用した。

## RESULTS, EFFECTS

### PROS

- **即座の修正**: 今日のデータが全 DATE 型テーブルのクエリで正しく返却される
- **書き込みの修正**: バックグラウンド同期が 00:00〜09:00 JST でも正しい日付で保存される
- **変更の局所性**: 接続プール初期化の設定変更のみ。クエリやリポジトリのコードは変更不要
- **TZ チェーンの一貫性**: ウェアラブル API（JST）→ Go API（JST）→ PostgreSQL（JST セッション）の一貫したタイムゾーンチェーンが確立
- **既存データへの影響なし**: 旧 `parseDate()`（UTC midnight）で書かれたデータは元々正しい。UPSERT パターンにより再同期で自動修正される

### CONS, TRADEOFF

- **単一タイムゾーン前提**: セッション TZ が Asia/Tokyo にハードコードされており、マルチタイムゾーン対応には追加設計が必要。ただし本プロジェクトは単一ユーザー前提のため問題にならない
- **`CURRENT_DATE` / `LOCALTIME` の挙動変化**: これらの SQL 関数はセッション TZ に依存するため、UTC ではなく JST の日付/時刻を返すようになる。現在コードベース内で使用されていないことを確認済み
- **暗黙的な規約**: TZ 設定がインフラ層に隠れているため、新規開発者が認識しづらい。本 ADR で文書化することで対処

## APPENDIX

### 変更ファイル一覧

| ファイル | 変更内容 |
|---|---|
| `api/infrastructure/database/postgres.go` | `pgxpool.New()` → `pgxpool.ParseConfig()` + `RuntimeParams["TimeZone"] = "Asia/Tokyo"` + `pgxpool.NewWithConfig()` |
| `ml/app/database.py` | asyncpg `create_pool` に `server_settings={"TimeZone": "Asia/Tokyo"}` を追加 |
| `preprocessor/app/database.py` | 同上 |

### 技術詳細

**Go API（pgx/v5）:**

`RuntimeParams` に `TimeZone` を設定すると、pgx はコネクションプール内の各接続確立時に `SET TimeZone = 'Asia/Tokyo'` を発行する。これにより全クエリでセッション TZ が JST となる。

```go
poolCfg, _ := pgxpool.ParseConfig(dsn)
poolCfg.ConnConfig.RuntimeParams["TimeZone"] = "Asia/Tokyo"
pool, _ := pgxpool.NewWithConfig(ctx, poolCfg)
```

**Python サービス（asyncpg）:**

`server_settings` パラメータで同等の設定を行う。

```python
pool = await asyncpg.create_pool(..., server_settings={"TimeZone": "Asia/Tokyo"})
```

### 検証結果

- Go 全テストパス（`go test ./...`）
- 全サービスのヘルスチェック正常
- PostgreSQL 上で暗黙変換が正しく動作することを確認:
  - `SET TimeZone = 'Asia/Tokyo'; SELECT TIMESTAMPTZ '2026-02-18 15:00:00 UTC'::DATE;` → `2026-02-19` ✅
