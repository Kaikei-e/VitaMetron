# Divergence Range API で今日の divergence をオンデマンド計算する

## ADR's STATUS

採用済み (2026-02-19)

## CONTEXT

ADR-000003 で PostgreSQL セッション TZ を `Asia/Tokyo` に設定し、DATE 列クエリの1日ずれ問題を解消した。しかし `/conditions` ページの「Actual vs Expected Condition」チャートでは依然として今日のデータが表示されなかった。

### 根本原因

Divergence の算出フローには2つのエンドポイントがある:

| エンドポイント | 用途 | ML フォールバック |
|---|---|---|
| `GET /api/divergence?date=` | 単一日付 | あり（DB になければ ML に計算を依頼） |
| `GET /api/divergence/range?from=&to=` | 範囲取得 | **なし（DB 読み取りのみ）** |

フロントエンドは range エンドポイントを使用してチャートデータを取得する。しかし range エンドポイントは DB からの読み取りしか行わないため、今日の divergence が未計算の場合は結果に含まれない。

**データフロー（修正前）:**

```
Frontend SSR  →  GET /api/divergence/range?from=01-20&to=02-19
Go API        →  divergenceRepo.ListRange(from, to)  ← DB 読み取りのみ
DB            →  divergence_detections に今日の行がない → 返却されない
```

- 単一日付エンドポイントには ML フォールバックがあるが、range にはない
- Divergence を定期計算するスケジューラは存在しない
- ML サービスの `/divergence/detect` は内部で DB キャッシュを確認し、未計算なら計算→永続化→返却する設計

## DECISION MAKING

### 検討した選択肢

| 選択肢 | 概要 | 評価 |
|---|---|---|
| A. スケジューラで定期計算 | cron/スケジューラで毎日自動計算 | △ インフラ追加、主観ログ入力タイミングとの同期が困難 |
| B. フロントエンドで単一日付 API を並行呼び出し | range + 今日分の個別 API を SSR で並行取得 | △ フロントエンドの複雑化、データ結合ロジックが必要 |
| C. range API 内で今日分をオンデマンド計算 | DB クエリ前に ML へ今日分の計算を依頼 | ✅ 採用 |

### 選択肢 C を採用した理由

- **変更箇所が1ファイル**: Go API のハンドラのみの修正で完結
- **ML サービスの既存キャッシュ機構を活用**: ML の `/divergence/detect` は DB にキャッシュ済みなら即座に返し、未計算なら計算→永続化する。この特性により、2回目以降の呼び出しは実質 DB 読み取りのみとなる
- **耐障害性**: ML 呼び出しのエラーは無視するため、ML ダウン・モデル未学習・データ不足でも range の既存データは正常に返却される
- **レイテンシ影響が限定的**: 計算対象は今日1日分のみ。初回は ML 計算で ~50-100ms、以降はキャッシュヒットで即座に返る

## RESULTS, EFFECTS

### PROS

- **今日のデータがチャートに表示される**: range クエリの前に ML 計算が走るため、DB クエリ時点では今日のデータが永続化済み
- **既存の挙動を壊さない**: 過去日のデータは従来通り DB から取得。ML 呼び出しは今日分のみ
- **冪等性**: ML サービスの DB キャッシュにより、同じ日付の計算は何度呼んでも同一結果を返す
- **変更の局所性**: ハンドラ1ファイルの修正のみ。DB スキーマ・ML サービス・フロントエンドの変更は不要

### CONS, TRADEOFF

- **range リクエストに ML 呼び出しが含まれる**: 初回のみ計算コストが発生する。ただし今日1日分のみであり、キャッシュヒット後は無視できるレベル
- **過去の未計算日はカバーしない**: 今日分のみのオンデマンド計算であり、過去日の欠損はバックフィルで対処する前提。現状の運用では問題にならない
- **ML サービスへの暗黙的な依存**: range API が ML サービスに依存するようになるが、エラー無視により可用性には影響しない

## APPENDIX

### 変更ファイル

| ファイル | 変更内容 |
|---|---|
| `api/handler/divergence.go` | `GetDivergenceRange` に今日分のオンデマンド ML 計算を追加 |

### 実装詳細

DB の range クエリ前に、リクエスト範囲内に今日が含まれるかを判定し、含まれる場合のみ ML サービスへ計算を依頼する:

```go
todayDate := time.Now().In(jst).Format("2006-01-02")
if todayDate >= from.Format("2006-01-02") && todayDate <= to.Format("2006-01-02") {
    if todayTime, err := parseDate(todayDate); err == nil {
        // ML は DB キャッシュを確認し、未計算なら計算→永続化する
        // エラーは無視（ML ダウンでも range の DB 結果は返す）
        h.mlClient.DetectDivergence(c.Request().Context(), todayTime)
    }
}
```

### 検証結果

- `go test ./handler/...` 全テストパス
- API コンテナのリビルド・再起動後、`/api/divergence/range?from=2026-02-18&to=2026-02-19` で今日 (02-19) のデータが返却されることを確認
