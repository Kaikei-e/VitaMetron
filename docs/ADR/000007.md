# 当日 ML スコアの陳腐化防止 ("Today Always Recompute" 方式)

## ADR's STATUS

採用済み (2026-02-21)

## CONTEXT

VRI Score・Anomaly Detection・HRV Prediction・Divergence Detection の各 ML エンドポイントは、一度計算した結果をデータベーステーブル（`vri_scores`, `anomaly_detections`, `hrv_predictions`, `divergence_detections`）にキャッシュし、次回以降はキャッシュを返す設計になっている。

しかし、Fitbit API からのデータは1日を通じて段階的に到着する。特に睡眠データは起床後数時間かけて確定するため、早朝に計算されたスコアは不完全なデータに基づいている。例えば:

1. 06:00 — Fitbit sync が走り、`daily_summaries` に不完全な睡眠データが書き込まれる
2. 06:00 — VRI が初回リクエストで計算・キャッシュされる（不完全データ → 異常な z-score → 低 VRI）
3. 11:00 — Fitbit sync が走り、`daily_summaries` の睡眠データが確定値に更新される
4. 11:00 — VRI リクエスト → **キャッシュが返され、確定データでの再計算が行われない**

この問題は VRI だけでなく、同じキャッシュパターンを持つ全 ML エンドポイントに共通していた。

なお、Divergence の Go API range handler には当日の on-demand recompute パターンが既に実装されていたが、ML 側がキャッシュを返すため実質的に機能していなかった。

## DECISION MAKING

### 検討した選択肢

| 選択肢 | 概要 | 評価 |
|---|---|---|
| A. Fitbit sync 後にキャッシュ無効化 | sync 完了時に該当日のキャッシュ行を DELETE | △ sync と ML の結合度が上がる、sync が複数回走る度に無効化ロジックが必要 |
| B. computed_at と sync 時刻を比較して鮮度判定 | キャッシュの computed_at が最新 sync より古ければ再計算 | △ sync 時刻の追跡が必要、比較ロジックが複雑 |
| C. 当日は常に再計算 ("Today Always Recompute") | `date >= today()` なら DB キャッシュをスキップして毎回再計算 | ✅ 採用 |

### 選択肢 C を採用した理由

- **シンプルさ**: 日付比較のみで判定でき、追加のメタデータ管理が不要
- **Fitbit API の特性に適合**: [Fitbit 公式ドキュメント](https://dev.fitbit.com/build/reference/web-api/heartrate-variability/get-hrv-summary-by-date/)が推奨する「正午と深夜にクエリ」というパターンと整合する。当日データは一日中変動し得るため、常に最新で計算するのが正しい
- **過去日のキャッシュは安全**: 過去日のデータは確定しているため、キャッシュ効率は維持される
- **既存パターンの統一**: Divergence range handler に既にあった on-demand recompute パターンを、VRI・Anomaly の range handler にも適用し一貫性を確保
- **計算コストの許容**: 単一ユーザーシステムのため、当日分の再計算（1日分）は十分に軽量

### 設計詳細

**ML 側 (Python/FastAPI)**: 各単一日エンドポイントで `date >= today()` の場合にキャッシュをスキップ

```python
@router.get("/vri")
async def get_vri(request, date):
    pool = request.app.state.db_pool

    # Today → always recompute (data may have changed since last sync)
    if date >= datetime.date.today():
        return await _compute_and_persist(pool, date)

    # Past dates → serve cache if available
    async with pool.acquire() as conn:
        row = await conn.fetchrow(FETCH_VRI_QUERY, date)
    if row is not None:
        return _row_to_response(row)
    return await _compute_and_persist(pool, date)
```

**Go API 側**: range handler で当日が範囲内に含まれる場合、DB クエリ前に ML エンドポイントを呼び出して最新値を永続化

```go
todayDate := time.Now().In(jst).Format("2006-01-02")
if todayDate >= from.Format("2006-01-02") && todayDate <= to.Format("2006-01-02") {
    if todayTime, err := parseDate(todayDate); err == nil {
        h.mlClient.GetVRI(c.Request().Context(), todayTime)
    }
}
```

## RESULTS, EFFECTS

### PROS

- **当日スコアが常に最新データを反映**: Fitbit sync 後にダッシュボードを開けば、確定データに基づくスコアが表示される
- **既存のキャッシュ効率を維持**: 過去日のキャッシュは従来通り即座に返される
- **全 ML エンドポイントで一貫した動作**: VRI / Anomaly / HRV Prediction / Divergence すべてが同じパターンに統一
- **Go API range handler の統一**: VRI・Anomaly の range handler にも Divergence と同じ today recompute パターンを適用

### CONS, TRADEOFF

- **当日の再計算コスト**: 当日のスコアは毎リクエストで再計算されるため、ベースライン統計（60日ウィンドウ）の SQL クエリが毎回発行される。単一ユーザーシステムでは問題ないが、マルチユーザーにスケールする場合は TTL ベースの短時間キャッシュの追加を検討する必要がある
- **`>=` 比較の設計意図**: `date >= today()` としており、未来日のリクエストも常に再計算する。未来日にはデータが存在しないため neutral/default 値が返り、実害はない

## APPENDIX

### 変更ファイル一覧

| ファイル | 変更内容 |
|---|---|
| `ml/app/routers/vri.py` | `get_vri()`: `date >= today()` の場合キャッシュをスキップして再計算 |
| `ml/app/routers/anomaly.py` | `detect_anomaly()`: 同上 |
| `ml/app/routers/hrv_predict.py` | `predict_hrv()`: 同上 |
| `ml/app/routers/divergence.py` | `detect_divergence()`: 同上 |
| `api/handler/vri.go` | `GetVRIRange()`: 当日が範囲内なら ML 呼び出しで最新値を永続化 |
| `api/handler/anomaly.go` | `GetAnomalyRange()`: 同上 |

### テスト修正

既存テストの前提値が実装と乖離していたため、併せて修正:

| ファイル | 修正内容 |
|---|---|
| `ml/tests/test_anomaly_features.py` | `ANOMALY_FEATURE_NAMES` のカウントを 19 → 21 に更新 |
| `ml/tests/test_hrv_features.py` | `HRV_FEATURE_NAMES` のカウントを 26 → 29 に更新、テストデータに deep sleep HRV フィールドを追加 |
| `ml/tests/test_quality.py` | `rule_based_score` のスケール変更 (1-5 → 0-100) に合わせてアサーション値を修正 |
